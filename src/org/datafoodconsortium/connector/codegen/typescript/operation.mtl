[comment encoding = UTF-8 /]
[module operation('http://www.eclipse.org/uml2/5.0.0/UML')]

[import org::datafoodconsortium::connector::codegen::typescript::common /]
[import org::datafoodconsortium::connector::codegen::typescript::commonTypescript /]

[template public generateOperationImplementation(aClass: Class, operation: Operation)]
[if (operation.isConstructor())][if not (aClass.isAbstract)][genConstructorSignatureWithSemanticId(aClass, operation)/]
[genConstructorSignatureCopy(aClass, operation)/]
[/if][genConstructorSignatureImplementation(aClass, operation)/][else]public [generateOperationSignature(aClass, operation) /] {
[if (isGetter(operation))]
	[generateGetterBody(aClass, operation)/]
[elseif (isSetter(operation))]
	[generateSetterBody(aClass, operation)/]
[elseif (isAdder(operation))]
	[generateAdderBody(aClass, operation)/]
[elseif (isRemover(operation))]
	[generateRemoverBody(aClass, operation)/]
[/if]
}
[/if]
[/template]

[template public genConstructorSignatureWithSemanticId(aClass: Class, operation: Operation)]public constructor(parameters: {[if (aClass.isSemantic())]semanticId[if (aClass.isBlankNode())]?[/if]: string[if (aClass.isBlankNode())], semanticType?: string[/if][/if][comment if (aClass.isSemantic() and aClass.isBlankNode())semanticType: string[/if /][if aClass.isSemantic() and not (operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in))->isEmpty())], [/if][genConstructorParameters(aClass, operation)/]});[/template]
[template public genConstructorSignatureCopy(aClass: Class, operation: Operation)]public constructor(parameters: {[if (aClass.isSemantic())]other: Semanticable[/if][if aClass.isSemantic() and not (operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in))->isEmpty())], [/if][genConstructorParameters(aClass, operation)/]});[/template]
[template public genConstructorSignatureImplementation(aClass: Class, operation: Operation)][if (aClass.isAbstract)]protected[else]public[/if] constructor(parameters: {[if (aClass.isSemantic() or aClass.isAbstract)]semanticId?: string, [if (aClass.isAbstract or aClass.isBlankNode())]semanticType?: string, [/if]other?: Semanticable[/if][if (aClass.isSemantic() or aClass.isAbstract) and not (operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in))->isEmpty())], [/if][genConstructorParameters(aClass, operation)/]}) {
	[generateConstructorBody(aClass, operation)/]
}[/template]

[template public generateConstructorBody(class: Class, operation: Operation)]
[if not (class.generalization->isEmpty()) or class.isSemantic()]super([generateConstructorSuper(operation, class)/]);[/if]
[if (not class.isBlankNode() and class.generalization->isEmpty())]connector.store(this);[/if]
[if not (class.isAbstract)]if (parameters.other && this.isSemanticSameTypeOf(parameters.other)) throw new Error();[/if]
[for (p: Parameter | operation.ownedParameter->select(p: Parameter | not p.isInitializerParent())) separator('\n')]if (parameters.[p.name/]) [if (p.upper = 1)]this.[getSetter(p).name /](parameters.[p.name /])[else]parameters.[p.name /].forEach(e => this.[getAdder(p).name /](e))[/if];[/for]
[/template]

[comment handle initializer / initializer parent /]
[template public generateConstructorSuper(constructor: Operation, aClass: Class)]
[let hasGeneralization: Boolean = (not aClass.generalization->isEmpty())][if (hasGeneralization)]{[/if][if (aClass.isSemantic())][if (hasGeneralization)]semanticId: [/if]parameters.semanticId, [if (hasGeneralization)]semanticType: [/if]parameters.other? parameters.other.getSemanticType(): [if (aClass.isAbstract)]parameters.semanticType, [else]"[class.getValue(class.getAppliedStereotype('datafoodconsortium_connector::semantic'), 'map')/]", [/if][if (hasGeneralization)]other: [/if]parameters.other[/if][if (aClass.isSemantic() and not constructor.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in and p.isInitializerParent()))->isEmpty())], [/if][for (parameter: Parameter | constructor.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in and p.isInitializerParent()))) separator(', ')][parameter.name/]: parameters.[parameter.name/][/for][if (hasGeneralization)]}[/if][/let]
[/template]

[template public genConstructorParameters(aClass: Class, operation: Operation)]
[for (parameter: Parameter | operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in))) separator(', ')][parameter.name/]?: [generateType(parameter.type.name, parameter.upper) /][/for]
[/template]

[template public getInitializationValueForType(type: String, upper: Integer)]
[if upper = -1]['[]'/][elseif type = 'String']""[elseif type = 'Boolean']false[elseif type = 'Integer']0[elseif type = 'Real']0.0[else]nil[/if]
[/template]

[template public generateAdderBody(aClass: Class, operation: Operation)]
[let parameter: Parameter = operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in))->at(1)][let property: Property = getPropertyOfAdder(aClass, operation)][if (not parameter.type.isPrimitive() and not parameter.type.isBlankNode())]connector.store([parameter.name/]);[/if]
this.addSemanticProperty[if (parameter.type.isPrimitive())]Literal[else]Reference[/if]("[property.getValue(property.getAppliedStereotype('datafoodconsortium_connector::semantic'), 'map')/]", [parameter.name/]);[/let][/let]
[/template]

[template public generateGetterBody(aClass: Class, operation: Operation)]
[let property: Property = getPropertyOfGetter(aClass, operation)]
[let returned: Parameter = operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::return))->at(1)]
[let type: String = generateTypeWithDefaultUndefined(returned)]
[let map: OclAny = property.getValue(property.getAppliedStereotype('datafoodconsortium_connector::semantic'), 'map')]
[if (property.isPropertyMultiple())]const results = new [type/]();
const properties = this.getSemanticPropertyAll("[map/]");
for await (const semanticId of properties) {
	const semanticObject: Semanticable | undefined = await connector.fetch(semanticId, options);
	if (semanticObject) results.push(<([returned.type.name/] & Semanticable)> semanticObject);
}
return results;[elseif (not returned.type.isPrimitive())]
let result: [type/] = undefined;
const semanticId = this.getSemanticProperty("[map/]");
if (semanticId) {
	const semanticObject: Semanticable | undefined = await connector.fetch(semanticId, options);
	if (semanticObject) result = <[type/]> semanticObject;
}
return result;
[else]
return this.getSemanticProperty("[map/]");[/if]
[/let][/let][/let][/let]
[/template]

[template public generateSetterBody(aClass: Class, operation: Operation)]
[comment if object is a reference, store it /]
[comment throws getObject is null/]
[let parameter: Parameter = operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in))->at(1)]
[if (not parameter.type.isPrimitive() and not parameter.type.isBlankNode())]connector.store([parameter.name/]);[/if]
this.setSemanticProperty[if (parameter.type.isPrimitive())]Literal[else]Reference[/if]("[getPropertyOfSetter(aClass, operation).getValue(getPropertyOfSetter(aClass, operation).getAppliedStereotype('datafoodconsortium_connector::semantic'), 'map')/]", [operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::_in)).name/]);[/let]
[/template]

[template public generateRemoverBody(aClass: Class, operation: Operation)]
throw new Error("Not yet implemented.");
[/template]

[template public generateOperationSignature(aClass: Class, operation: Operation)]
[let isAsyncGetter: Boolean = (operation.isGetter() and (getPropertyOfGetter(aClass, operation).isPropertyMultiple() or not operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::return))->at(1).type.isPrimitive()))][if (operation.isConstructor())]constructor[else][if (operation.isAbstract)]abstract [/if][if (isAsyncGetter)]async [/if][operation.name/][/if]([if (isAsyncGetter)]options?: IGetterOptions[else][genOperationParameters(operation)/][/if])[if not (operation.isConstructor())]: [generateOperationReturn(operation)/][/if][/let]
[/template]

[template public generateOperationReturn(operation: Operation)]
[if (operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::return))->isEmpty())]
void[else]
[let parameter: Parameter = operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::return))->at(1)]
[if (operation.isGetter() and not parameter.type.isPrimitive() and not parameter.type.isBlankNode())]Promise<[operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::return)).genOperationParameter()/][if (parameter.upper = 1)] | undefined[/if]>[else][operation.ownedParameter->select(p: Parameter | (p.direction = ParameterDirectionKind::return)).genOperationParameter()/][/if]
[/let]
[/if]
[/template]

[template public genOperationParameters(anOperation: Operation)]
[anOperation.ownedParameter->select(param : Parameter | (param.direction = ParameterDirectionKind::_in)).genOperationParameter()->sep(', ')/]
[/template]

[template public genOperationParameter(parameter: Parameter)]
[if (parameter.direction = ParameterDirectionKind::_in)][parameter.name/]: [/if][generateType(parameter)/]
[/template]

